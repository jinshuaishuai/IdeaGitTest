package com.pattern.bi;

/**
 * @author shuai.jin
 * @date 2020/9/11 14:07
 */
public class Group extends BaseAggregation{


    public Group(Object object) {
        /*
            它是拖入一个字段，每更改一次字段里的属性算法，结果就实时的做出响应

            可不可以这样啊，在service层添加一套业务处理子层，用于添加对查询结果的各种过滤条件。

            现在唯一不知道如何处理的地方是，每拖入字段，结果实时更新，拖入字段指的是拖入维度字段和指标字段，
            每次更改字段里提前预备的条件，结果实时更新，


            它应该是拆解出字段和字段中的预备条件，做综合处理之后，形成可执行的SQL，然后执行SQL，将SQL执行
            的结果进行显示，拆解字段包括拆解维度中的字段和指标中的字段，
            目前这种分析是针对含有横轴和纵轴的图而言的。
            每做出一次查询的动作，就重复执行一次上面的动作。
         */
        super(object);
    }

    public String sameValueInGroup(Object object) {
        /*
            现在的任务是分析，这个函数的参数是什么，函数返回值是什么。
            如果参数是字段和字段中的过滤条件，

            可以确定的一点是：函数的返回值是一段拼接后的SQL
            函数的入参是什么，是一个横轴字段，可是一个横轴里可以拖进来多个字段，这个时候怎样进行
            对过滤条件进行处理呢，之前说的，是生成一段SQL字段，那么这个时候怎样生成SQL字段呢？
            按什么样的生成逻辑呢，

            还是没有确定函数的参数是什么啊，这个有什么难以确定的吗？

            参数就是一个字段对象。该字段里包含有排序方式，分组方式，等


            TODO 待考虑的一点，如果横轴或纵轴只拖进一个字段的情况，结果如何显示，实质是SQL怎样拼接。

            添加过滤条件后，返回的结果还要好好设计一下呢
         */

        System.out.println("相同的值为一组");
        System.out.println("返回一段处理后的SQL");
        return null;
    }

    public String customizeGroup(Object object) {
        System.out.println("自定义分组");
        System.out.println("返回一段处理后的SQL");
        /*
            这里有一个问题，如果用户填入的字段过滤条件不是实时保存的

            自定义分组是不是将查询出的分组结果在代码层面做了处理。

            还有一种实现方式是:一次性查询出所有的数据，放到内存中，对内存中的数据，在代码层面做操作。

            还是继续上一步骤的分析：能不能一次性查出所有的数据，放到内存中，在代码层面做操作？
            阿科那边就通不过，如果这种方式不行，一次查出部分的数据做分析，也就是组装SQL，进行查询
         */
        return null;
    }
}
